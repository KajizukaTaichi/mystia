mod block;
mod expr;
mod lexer;
mod oper;
mod stmt;
mod utils;
mod value;

use chrono::Local;
use sha2::{Digest, Sha256};
use std::collections::HashMap;

use {
    block::Block,
    expr::Expr,
    lexer::{str_escape, tokenize},
    oper::Oper,
    stmt::Stmt,
    utils::{OPERATOR, RESERVED, SPACE, expand_local, include_letter},
    value::{Type, Value},
};

pub trait Node {
    fn compile(&self, ctx: &mut Compiler) -> Option<String>;
    fn type_infer(&self, ctx: &mut Compiler) -> Option<Type>;
    fn parse(source: &str) -> Option<Self>
    where
        Self: Node + Sized;
}

#[derive(Debug, Clone)]
pub struct Compiler {
    /// メモリアロケーション用のアドレス
    index: i32,
    /// 文字列データ
    data: Vec<String>,
    /// 代入時に展開される配列
    array: Vec<String>,
    /// 関数定義コードの集合
    declare: Vec<String>,
    /// 型推論：変数の名前と型
    variable: HashMap<String, Type>,
    /// 型推論：関数の名前と引数と戻り値の型
    function: HashMap<String, (Vec<Type>, Type)>,
    /// 型推論：引数の名前と型
    argument: HashMap<String, Type>,
}

impl Compiler {
    pub fn new() -> Self {
        Compiler {
            index: 0,
            data: vec![],
            array: vec![],
            declare: vec![],
            variable: HashMap::new(),
            function: HashMap::new(),
            argument: HashMap::new(),
        }
    }

    pub fn build(&mut self, source: &str) -> Option<String> {
        let ast = Block::parse(source)?;
        let ret = ast.type_infer(self)?;
        Some(format!(
            "{5}\n(module (memory $mem 1) {2} {3} (func (export \"_start\") {1} {4} {0}))",
            ast.compile(self)?,
            config_return!(ret, self)?,
            join!(self.data),
            join!(self.declare),
            expand_local(self)?,
            format!(
                ";; Generated by Mystia compiler on {}\n;; Source Hash: {:x}",
                Local::now().format("%Y/%m/%d %H:%M:%S"),
                {
                    let mut hasher = Sha256::new();
                    hasher.update(source.as_bytes());
                    hasher.finalize()
                }
            )
        ))
    }
}
